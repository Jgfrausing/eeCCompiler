//Generated by the GOLD Parser Builder

using System;
using System.Collections.Generic;
using System.IO;
using eeCCompiler.Indexes;
using eeCCompiler.Interfaces;
using eeCCompiler.Nodes;
using GOLD;
using static eeCCompiler.Indexes.Indexes.ProductionIndex;
using Type = eeCCompiler.Nodes.Type;

internal class MyParser
{
    private readonly Parser _parser = new Parser();

    public readonly List<AbstractSyntaxTree> List = new List<AbstractSyntaxTree>(); //Is public for debugging only
    public readonly Stack<AbstractSyntaxTree> ReductionStack = new Stack<AbstractSyntaxTree>(); //Is public for debugging only
    //public readonly Stack<IValue> ValueStack = new Stack<IValue>(); //Is public for debugging only

    public Root Root;

    public MyParser()
    {
        //Loads the tables created by GOLD parser
        _parser.LoadTables(@"..\..\eec.egt");
    }

    public bool Parse(TextReader reader)
    {
        //This procedure starts the GOLD Parser Engine and handles each of the messages it returns. 
        //The resulting tree is a pure representation of the language and will be ready to implement.

        var accepted = false; //Was the parse successful?

        _parser.Open(reader);
        _parser.TrimReductions = false; //Please read about this feature before enabling  

        var done = false;
        while (!done)
        {
            var response = _parser.Parse();

            switch (response)
            {
                case ParseMessage.Reduction:
                    //Create a customized object to store the reduction
                    var currentReduction = CreateNewObject(_parser.CurrentReduction as Reduction);
                    if (currentReduction != null)
                        ReductionStack.Push(currentReduction);
                    List.Add(currentReduction); //For debuging
                    break;

                case ParseMessage.Accept:
                    //Accepted!
                    Root = ReductionStack.Pop() as Root;
                    done = true;
                    accepted = true;
                    break;

                case ParseMessage.TokenRead:
                    //Checkes token for Literals and Identifiers
                    CheckToken();
                    break;

                    #region Errors

                case ParseMessage.LexicalError:
                    //Cannot recognize token
                    done = true;
                    break;

                case ParseMessage.SyntaxError:
                    //Expecting a different token
                    done = true;
                    break;

                case ParseMessage.InternalError:
                    //INTERNAL ERROR! Something is horribly wrong.
                    done = true;
                    break;

                case ParseMessage.NotLoadedError:
                    //This error occurs if the CGT was not loaded.                   
                    done = true;
                    break;

                case ParseMessage.GroupError:
                    //GROUP ERROR! Unexpected end of file
                    done = true;
                    break;

                    #endregion
            }
        } //while
        if (List.Contains(null) || ReductionStack.Count != 0)
            accepted = false; //A reduction returned null or was handled wrong (Compiler error - NOT input error)
        return accepted;
    }

    private void CheckToken()
    {
        
        var s = _parser.CurrentToken().Parent.ToString();
        switch (s)
        {
            /*
            case "FloatLiteral":
                ValueStack.Push(new NumValue(double.Parse(_parser.CurrentToken().Data.ToString())));
                break;

            case "BooleanLiteral":
                ValueStack.Push(new BoolValue(bool.Parse(_parser.CurrentToken().Data.ToString())));
                break;

            case "StringLiteral":
                ValueStack.Push(new StringValue(_parser.CurrentToken().Data.ToString()));
                break;
                */
            case "Id":
                ReductionStack.Push(new Identifier(_parser.CurrentToken().Data.ToString()));
                break;
        }
    }

    private AbstractSyntaxTree CreateNewObject(Reduction r)
    {
        /*
        Giving that this is a buttom up parser nodes/reductions are pushed onto a stack when created.
        If a reduction needs other nodes, they are retrived from the stact in reverced order. 
        This means that a program gets created with:
            <Program> ::= <consts> <struct_defs> program '{' <body> '}' <Func_decls>
        <Func_decls> poped from the stack, THEN <body>, THEN <struct_defs>, and THEN <consts>

        Non terminals that reduces to nothing are made as a new instance of its corresponding class
        
        Non terminals that reduced to another single reduction is handled by adding a interface to the new reduction:
            <value> ::= <func_call>
        Here FunctionCall implements the IValue interface. Since all new reductions are pushed onto the stack we
        pops the <func_call> thats on the stack and then pushes it back. When a reduction later needs a <value>
        it expects a object implementing IValue.
        
        Non terminals that works as a list are implemented by retriving objects. (See CreateFunctionDeclarationList() method)
            <Func_decls> ::= <func_decl> <Func_decls>
        Here <Func_decls> (LHS) is popped from the stack. Then <func_decl> gets inserted at first element of <Func_decls>'s
        list. <Func_decls> is then pushed back onto the stack.

        There are multiple "possible" null references. These are handled by the "syntax error case" in Parse();. They are therefore
        not checked here.
        */

        AbstractSyntaxTree result = null;
        //Returnvalue   OBS! Is sometimes used as placeholder, when multiple objects needs popped from the stack.
        switch ((Indexes.ProductionIndex) r.Parent.TableIndex())
        {
                #region Program

            case Program_Program_Lbrace_Rbrace:
                // <Program> ::= <consts> <struct_defs> program '{' <body> '}' <Func_decls>
                result = new Root(ReductionStack.Pop() as FunctionDeclarations, ReductionStack.Pop() as Body, ReductionStack.Pop() as StructDefinitions, ReductionStack.Pop() as ConstantDefinitions, ReductionStack.Pop() as Includes);
                break;

                #endregion

                #region Include

            case Includes_Include:
                // <includes> ::= include <include> <includes>
                var includes = ReductionStack.Pop() as Includes;
                includes.IncludeList.Insert(0, ReductionStack.Pop() as Include);
                result = includes;
                break;

            case Indexes.ProductionIndex.Includes:
                // <includes> ::= 
                result = new Includes();
                break;

            case Include_Id_Dot:
                // <include> ::= Id '.' <include>
                var include = ReductionStack.Pop() as Include;
                include.Identifiers.Insert(0, ReductionStack.Pop() as Identifier);
                result = include;
                break;

            case Include_Id:
                // <include> ::= Id 
                result = new Include(new List<Identifier>() { ReductionStack.Pop() as Identifier});
                break;

                #endregion

                #region Const

            case Consts:
                // <consts> ::= <const> <consts>
                result = CreateConstants();
                break;

            case Consts2:
                // <consts> ::= 
                result = new ConstantDefinitions();
                break;

            case Const_Const_Id_Semi:
                // <const> ::= const Id <const_part> ';'
                result = new Constant(ReductionStack.Pop() as IConstantPart, ReductionStack.Pop() as Identifier);
                break;

                #endregion

                #region Func_decl

            case Func_decls:
                // <Func_decls> ::= <func_decl> <Func_decls>
                result = CreateFunctionDeclarationList();
                break;

            case Func_decls2:
                // <Func_decls> ::= 
                result = new FunctionDeclarations();
                break;

            case Func_decl_Lparen_Rparen_Lbrace_Rbrace:
                // <func_decl> ::= <typeid> '(' <typeid_list> ')' '{' <body> '}'
                result = new FunctionDeclaration(ReductionStack.Pop() as Body, ReductionStack.Pop() as TypeIdList, ReductionStack.Pop() as TypeId);
                break;

                #endregion

                #region TypeId

            case Typeid_list:
            // <typeid_list> ::= <typeid> <extra_typeid>
            //FALLTHROUGH

            case Extra_typeid_Comma:
                result = CreateTypeIdList();
                break;

            case Typeid_list2:
            // <typeid_list> ::= 
            //FALLTHROUGH

            case Extra_typeid:
                // <extra_typeid> ::= 
                result = new TypeIdList();
                break;

            case Typeid_Id:
                // <typeid> ::= <type> Id
                result = new TypeId(ReductionStack.Pop() as Identifier, ReductionStack.Pop() as IType);
                break;

                #endregion

                #region Var_decl

            case Var_decls_Semi:
                // <var_decls> ::= <var_decl> <var_decls>
                result = CreateVarDeclerations();
                break;

            case Var_decls:
                // <var_decls> ::= 
                result = new VarDeclerations();
                break;

            case @Var_decl_Id:
                // <var_decl> ::= Id <assign_opr> <expr>
                result = new VarDecleration(ReductionStack.Pop() as IExpression, ReductionStack.Pop() as AssignmentOperator, ReductionStack.Pop() as Identifier);
                break;

                #endregion

                #region Struct

            case Struct_decl_Id_Id_Lbrace_Rbrace:
                // <struct_decl> ::= Id <assign_opr> Id '{' <var_decls> '}'
                result = new StructDecleration(ReductionStack.Pop() as VarDeclerations, ReductionStack.Pop() as Identifier, ReductionStack.Pop() as AssignmentOperator, ReductionStack.Pop() as Identifier);
                break;

            case Struct_defs:
                // <struct_defs> ::= <struct_def> <struct_defs>
                result = CreateStructDefinitions();
                break;

            case Struct_defs2:
                // <struct_defs> ::= 
                result = new StructDefinitions();
                break;

            case Struct_def_Struct_Id_Lbrace_Rbrace:
                // <struct_def> ::= struct Id '{' <struct_parts> '}'
                result = new StructDefinition(ReductionStack.Pop() as StructParts, ReductionStack.Pop() as Identifier);
                break;

            case Struct_parts_Semi:
            // <struct_parts> ::= <var_decl> <struct_parts>
            //FALLTHROUGH

            case Struct_parts:
                // <struct_parts> ::= <func_decl> <struct_parts>
                result = CreateStructParts();
                break;

            case Struct_parts2:
                // <struct_parts> ::= 
                result = new StructParts();
                break;

                #endregion

                #region Operators

            case Operator_Lt:
                // <operator> ::= '<'
                result = new Operator(Indexes.SymbolIndex.Lt);
                break;

            case Operator_Gt:
                // <operator> ::= '>'
                result = new Operator(Indexes.SymbolIndex.Gt);
                break;

            case Operator_Lteq:
                // <operator> ::= '<='
                result = new Operator(Indexes.SymbolIndex.Lteq);
                break;

            case Operator_Gteq:
                // <operator> ::= '>='
                result = new Operator(Indexes.SymbolIndex.Gteq);
                break;

            case Operator_And:
                // <operator> ::= and
                result = new Operator(Indexes.SymbolIndex.And);
                break;

            case Operator_Or:
                // <operator> ::= or
                result = new Operator(Indexes.SymbolIndex.Or);
                break;

            case Operator_Eqeq:
                // <operator> ::= '=='
                result = new Operator(Indexes.SymbolIndex.Eqeq);
                break;

            case Operator_Exclameq:
                // <operator> ::= '!='
                result = new Operator(Indexes.SymbolIndex.Exclameq);
                break;

            case Operator_Times:
                // <operator> ::= '*'
                result = new Operator(Indexes.SymbolIndex.Times);
                break;

            case Operator_Div:
                // <operator> ::= '/'
                result = new Operator(Indexes.SymbolIndex.Div);
                break;

            case Operator_Mod:
                // <operator> ::= mod
                result = new Operator(Indexes.SymbolIndex.Mod);
                break;

            case Operator_Plus:
                // <operator> ::= '+'
                result = new Operator(Indexes.SymbolIndex.Plus);
                break;

            case Operator_Minus:
                // <operator> ::= '-'
                result = new Operator(Indexes.SymbolIndex.Minus);
                break;

            case Assign_opr_Eq:
                // <assign_opr> ::= '='
                result = new AssignmentOperator(Indexes.SymbolIndex.Eq);
                break;

            case Assign_opr_Pluseq:
                // <assign_opr> ::= '+='
                result = new AssignmentOperator(Indexes.SymbolIndex.Pluseq);
                break;

            case Assign_opr_Minuseq:
                // <assign_opr> ::= '-='
                result = new AssignmentOperator(Indexes.SymbolIndex.Minuseq);
                break;

                #endregion

                #region Types

            case Type_Void:
                // <type> ::= void
                result = new Type("void");
                break;

            case Type_String:
                // <type> ::= string
                result = new Type("string");
                break;

            case Type_Num:
                // <type> ::= num
                result = new Type("num");
                break;

            case Type_Bool:
                // <type> ::= bool
                result = new Type("bool");
                break;

            case Type_Id:
                // <type> ::= Id
                result = ReductionStack.Pop() as Identifier;
                break;

            #endregion

                #region Values

            case Value_Floatliteral:
            // <value> ::= FloatLiteral
            //FALLTHROUGH

            case Const_part_Floatliteral:
                // <const_part> ::= FloatLiteral
                result = new NumValue(double.Parse(r.get_Data(0).ToString()));
                break;

            case Value_Stringliteral:
            // <value> ::= StringLiteral
            //FALLTHROUGH

            case Const_part_Stringliteral:
                // <const_part> ::= StringLiteral
                result = new StringValue(r.get_Data(0).ToString());
                break;

            case Value_Booleanliteral:
            // <value> ::= BooleanLiteral
            //FALLTHROUGH
            case Const_part_Booleanliteral:
                // <const_part> ::= BooleanLiteral'
                result = new BoolValue(bool.Parse(r.get_Data(0).ToString()));
                break;

            case Value:
                // <value> ::= <refrence>
                result = ReductionStack.Pop();
                break;

            case Indexes.ProductionIndex.Refrence:
                // <refrence> ::= <func_call>
                result = new Refrence(ReductionStack.Pop() as IStructRefrence);
                break;

            case Refrence_Id:
                // <refrence> ::= Id
                result = ReductionStack.Pop();
                break;

            case Refrence_Id_Dot:
                // <refrence> ::= Id '.' <refrence>
                result = new Refrence(ReductionStack.Pop() as Refrence, ReductionStack.Pop() as Identifier);
                break;

                #endregion

                #region Body&Bodypart

            case Indexes.ProductionIndex.Body:
                // <body> ::= <bodypart> <body>

                result = CreateBody();
                break;

            case Body2:
                // <body> ::= 
                result = new Body();
                break;

            case Bodypart_Semi:
                // <bodypart> ::= <var_decl> ';'

                result = ReductionStack.Pop();
                break;

            case Bodypart_Semi2:
                // <bodypart> ::= <struct_decl> ';'
                result = ReductionStack.Pop();
                break;

            case Bodypart_Semi3:
                // <bodypart> ::= <func_call> ';'
                result = ReductionStack.Pop();
                break;

            case Bodypart:
                // <bodypart> ::= <ctrl_stmt>
                result = ReductionStack.Pop();
                break;

            case Bodypart_Return_Semi:
                // <bodypart> ::= return <expr> ';'
                result = new Return(ReductionStack.Pop() as IExpression);
                break;

                #endregion

                #region Expressions

            case Expr:
                // <expr> ::= <value> <operator> <expr>
                result = new ExpressionValOpExpr(ReductionStack.Pop() as IExpression, ReductionStack.Pop() as Operator, ReductionStack.Pop() as IValue);
                break;

            case Expr2:
                // <expr> ::= <value>
                result = new ExpressionVal(ReductionStack.Pop() as IValue);
                break;

            case Expr_Lparen_Rparen:
                // <expr> ::= '(' <expr> ')'
                result = new ExpressionParen(ReductionStack.Pop() as IExpression);
                break;

            case Expr_Minus:
                // <expr> ::= '-' <expr>
                result = new ExpressionMinus(ReductionStack.Pop() as IExpression);
                break;

            case Expr_Lparen_Rparen2:
                // <expr> ::= '(' <expr> ')' <operator> <expr>
                result = new ExpressionParenOpExpr(ReductionStack.Pop() as IExpression, ReductionStack.Pop() as Operator, ReductionStack.Pop() as IExpression);
                break;

            case Expr_Exclam:
                // <expr> ::= '!' <expr>
                result = new ExpressionNegate(ReductionStack.Pop() as IExpression);
                break;

            case Expr_list:
            // <expr_list> ::= <expr> <opt_exprs>
            //Fallthrough

            case Opt_exprs_Comma:
                // <opt_exprs> ::= ',' <expr> <opt_exprs>
                result = CreateExpressionList();
                break;

            case Expr_list2:
            // <expr_list> ::= 
            //FallThrough

            case Opt_exprs:
                // <opt_exprs> ::= 
                result = new ExpressionList();
                break;

                #endregion

                #region ControlStatements

            case Ctrl_stmt_If_Lbrace_Rbrace:
            // <ctrl_stmt> ::= if <expr> '{' <body> '}' <if_exp>
            //FALLTHROUGH

            case If_exp_Else_If_Lbrace_Rbrace:
                // <if_exp> ::= else if <expr> '{' <body> '}' <if_exp>
                result = new IfStatement(ReductionStack.Pop() as ElseStatement, ReductionStack.Pop() as Body, ReductionStack.Pop() as IExpression);
                break;

            case Ctrl_stmt_Repeat_Lbrace_Rbrace:
            // <ctrl_stmt> ::= repeat <var_decl> <direction> <expr> '{' <body> '}'
            //FALLTHROUGH

            case Ctrl_stmt_Repeat_Lparen_Rparen_Lbrace_Rbrace:
                // <ctrl_stmt> ::= repeat '(' <var_decl> <direction> <expr> ')' '{' <body> '}'
                result = new RepeatFor(ReductionStack.Pop() as Body, ReductionStack.Pop() as IExpression, ReductionStack.Pop() as Direction, ReductionStack.Pop() as VarDecleration);
                break;

            case @Ctrl_stmt_Repeat_Lbrace_Rbrace2:
                // <ctrl_stmt> ::= repeat <expr> '{' Body '}'
                result = new RepeatExpr(ReductionStack.Pop() as Body, ReductionStack.Pop() as IExpression);
                break;

            case If_exp_Else_Lbrace_Rbrace:
                // <if_exp> ::= else '{' <body> '}'
                result = new ElseStatement(ReductionStack.Pop() as Body);
                break;

            case If_exp:
                // <if_exp> ::= 
                result = new ElseStatement(new Body());
                break;

                #endregion

                #region Direction

            case Direction_Downto:
                // <direction> ::= downto
                result = new Direction(false);
                break;

            case Direction_To:
                // <direction> ::= to
                result = new Direction(true);
                break;

                #endregion

                #region FunctionCall

            case Func_call_Id_Lparen_Rparen:
                // <func_call> ::= Id '(' <expr_list> ')'
                result = new FuncCall((ReductionStack.Pop() as ExpressionList).Expressions, ReductionStack.Pop() as Identifier);
                break;

                #endregion
        } //switch

        return result;
    }

    private AbstractSyntaxTree CreateFunctionDeclarationList()
    {
        var funcDecls = ReductionStack.Pop() as FunctionDeclarations;
        funcDecls.FunctionDeclaration.Insert(0, ReductionStack.Pop() as FunctionDeclaration);

        return funcDecls;
    }

    private AbstractSyntaxTree CreateTypeIdList()
    {
        var typeIds = ReductionStack.Pop() as TypeIdList;
        typeIds.TypeIds.Insert(0, ReductionStack.Pop() as TypeId);

        return typeIds;
    }

    private AbstractSyntaxTree CreateVarDeclerations()
    {
        var varDecls = ReductionStack.Pop() as VarDeclerations;
        varDecls.VarDeclerationList.Insert(0, ReductionStack.Pop() as VarDecleration);

        return varDecls;
    }

    private AbstractSyntaxTree CreateStructDefinitions()
    {
        var structDefs = ReductionStack.Pop() as StructDefinitions;
        structDefs.Definitions.Insert(0, ReductionStack.Pop() as StructDefinition);

        return structDefs;
    }

    private AbstractSyntaxTree CreateStructParts()
    {
        var structParts = ReductionStack.Pop() as StructParts;
        structParts.StructPartList.Insert(0, ReductionStack.Pop() as IStructPart);
        
        return structParts;
    }

    private AbstractSyntaxTree CreateBody()
    {
        var body = ReductionStack.Pop() as Body;
        body.Bodyparts.Insert(0, ReductionStack.Pop() as IBodypart);
        
        return body;
    }

    private AbstractSyntaxTree CreateConstants()
    {
        var constants = ReductionStack.Pop() as ConstantDefinitions;
        constants.ConstantList.Insert(0, ReductionStack.Pop() as Constant);
        return constants;
    }

    private AbstractSyntaxTree CreateExpressionList()
    {
        var exprs = ReductionStack.Pop() as ExpressionList;
        exprs.Expressions.Insert(0, ReductionStack.Pop() as IExpression);

        return exprs;
    }
    
} //MyParser