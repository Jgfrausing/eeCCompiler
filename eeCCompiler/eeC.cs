//Generated by the GOLD Parser Builder

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Runtime.Remoting;
using eeCCompiler;
using eeCCompiler.Indexes;
using eeCCompiler.Interfaces;
using eeCCompiler.Nodes;

class MyParser
{
    private readonly GOLD.Parser _parser = new GOLD.Parser();

    public readonly List<AbstractSyntaxTree> List = new List<AbstractSyntaxTree>();
    public readonly Stack<AbstractSyntaxTree> Stack = new Stack<AbstractSyntaxTree>();
    public readonly Stack<Identifier> Identifiers = new Stack<Identifier>();
    
    public Program program;     //You might derive a specific object

    public MyParser()
    {
        //This procedure can be called to load the parse tables. The class can
        //read tables using a BinaryReader.
        
        _parser.LoadTables("eec.egt");
    }
    
    public bool Parse(TextReader reader)
    {
        //This procedure starts the GOLD Parser Engine and handles each of the
        //messages it returns. Each time a reduction is made, you can create new
        //custom object and reassign the .CurrentReduction property. Otherwise, 
        //the system will use the Reduction object that was returned.
        //
        //The resulting tree will be a pure representation of the language 
        //and will be ready to implement.

        bool accepted = false;          //Was the parse successful?

        _parser.Open(reader);
        _parser.TrimReductions = false;  //Please read about this feature before enabling  

        AbstractSyntaxTree currentReduction = null;
        var done = false;
        while (!done)
        {
            var response = _parser.Parse();

            switch (response)
            {
                case GOLD.ParseMessage.Reduction:
                    //Create a customized object to store the reduction

                    currentReduction = CreateNewObject(_parser.CurrentReduction as GOLD.Reduction);
                    if(currentReduction != null)
                        Stack.Push(currentReduction);
                    List.Add(currentReduction);
                    break;

                case GOLD.ParseMessage.Accept:
                    //Accepted!
                    program = Stack.Pop() as Program;              
                    done = true;
                    accepted = true;
                    break;

                case GOLD.ParseMessage.TokenRead:
                    //Console.WriteLine("______________________________________________________");
                    //Console.WriteLine("Data: " + _parser.CurrentToken().Data.ToString());
                    //Console.WriteLine("Parent: " + _parser.CurrentToken().Parent.ToString());
                    //Console.WriteLine("Position: " + _parser.CurrentToken().Position().ToString());
                    //Console.WriteLine("Type: " + _parser.CurrentToken().Type().ToString());
                    if (_parser.CurrentToken().Parent.ToString() == "Id")
                        Identifiers.Push(new Identifier(_parser.CurrentToken().Data.ToString()));
                    //You don't have to do anything here.
                    break;

                #region Errors
                case GOLD.ParseMessage.LexicalError:
                    //Cannot recognize token
                    done = true;
                    break;

                case GOLD.ParseMessage.SyntaxError:
                    //Expecting a different token
                    done = true;
                    break;

                case GOLD.ParseMessage.InternalError:
                    //INTERNAL ERROR! Something is horribly wrong.
                    done = true;
                    break;

                case GOLD.ParseMessage.NotLoadedError:
                    //This error occurs if the CGT was not loaded.                   
                    done = true;
                    break;

                case GOLD.ParseMessage.GroupError:
                    //GROUP ERROR! Unexpected end of file
                    done = true;
                    break; 
                    #endregion
            }
        } //while

        return accepted;
    }
    
    private AbstractSyntaxTree CreateNewObject(GOLD.Reduction r)
    { 
        AbstractSyntaxTree result = null;
        Body body;
        Expression expr;
        ExpressionList exprs;
        Identifier id;
        List<IBodypart> bodyparts = new List<IBodypart>();
        List<Expression> expressionList = new List<Expression>();
        Constant constant;
        Constants constantList;
        List<Constant> constants = new List<Constant>();
        switch ( (Indexes.ProductionIndex) r.Parent.TableIndex())
        {
            #region Program
            case Indexes.ProductionIndex.Program_Program_Lbrace_Rbrace:
                // <Program> ::= <consts> <struct_defs> program '{' <body> '}' <Func_decls>
                body = Stack.Pop() as Body;
                constantList = Stack.Pop() as Constants;
                result = new Program(constantList.ConstantList, body);
                break;
            #endregion

            #region Const

            case Indexes.ProductionIndex.Consts:
                // <consts> ::= <const> <consts>
                constantList = Stack.Pop() as Constants;
                constant = Stack.Pop() as Constant;
                constants.Add(constant);
                constants.AddRange(constantList.ConstantList);
                result = new Constants(constants);
                break;

            case Indexes.ProductionIndex.Consts2:
                // <consts> ::= 
                result = new Constants();
                break;

            case Indexes.ProductionIndex.Const_Const_Id_Semi:
                // <const> ::= const Id <const_part> ';'
                result = new Constant(Identifiers.Pop(), Stack.Pop() as IConstantPart);
                break;

            case Indexes.ProductionIndex.Const_part_Floatliteral:
                // <const_part> ::= FloatLiteral
                result = new NumValue(2.2);
                break;

            case Indexes.ProductionIndex.Const_part_Stringliteral:
                // <const_part> ::= StringLiteral
                break;

            case Indexes.ProductionIndex.Const_part_Booleanliteral:
                // <const_part> ::= BooleanLiteral
                break;
            #endregion

            #region Func_decl
            case Indexes.ProductionIndex.Func_decls:
                // <Func_decls> ::= <func_decl> <Func_decls>
                break;

            case Indexes.ProductionIndex.Func_decls2:
                // <Func_decls> ::= 
                break;

            case Indexes.ProductionIndex.Func_decl_Lparen_Rparen_Lbrace_Rbrace:
                // <func_decl> ::= <typeid> '(' <typeid_list> ')' '{' <body> '}'
                break;
            #endregion

            #region TypeId
            case Indexes.ProductionIndex.Typeid_list:
                // <typeid_list> ::= <typeid> <extra_typeid>
                break;

            case Indexes.ProductionIndex.Typeid_list2:
                // <typeid_list> ::= 
                break;

            case Indexes.ProductionIndex.Extra_typeid_Comma:
                // <extra_typeid> ::= ',' <typeid> <extra_typeid>
                break;

            case Indexes.ProductionIndex.Extra_typeid:
                // <extra_typeid> ::= 
                break;

            case Indexes.ProductionIndex.Typeid_Id:
                // <typeid> ::= <type> Id
                break;
            #endregion

            #region Var_decl
            case Indexes.ProductionIndex.Var_decls:
                // <var_decls> ::= <var_decl> <var_decls>
                break;

            case Indexes.ProductionIndex.Var_decls2:
                // <var_decls> ::= 
                break;

            case Indexes.ProductionIndex.Var_decl_Id_Eq:
                // <var_decl> ::= Id '=' <expr>
                expr = Stack.Pop() as Expression;
                id = Identifiers.Pop();
                result = new VarDecleration(id, expr);
                break;
            #endregion

            #region Struct
            case Indexes.ProductionIndex.Struct_decl_Id_Eq_Id_Lbrace_Rbrace_Semi:
                // <struct_decl> ::= Id '=' Id '{' <var_decls> '}' ';'
                break;

            case Indexes.ProductionIndex.Struct_defs:
                // <struct_defs> ::= <struct_def> <struct_defs>
                break;

            case Indexes.ProductionIndex.Struct_defs2:
                // <struct_defs> ::= 
                break;

            case Indexes.ProductionIndex.Struct_def_Struct_Id_Lbrace_Rbrace:
                // <struct_def> ::= struct Id '{' <struct_parts> '}'
                break;

            case Indexes.ProductionIndex.Struct_parts:
                // <struct_parts> ::= <var_decl> <struct_parts>
                break;

            case Indexes.ProductionIndex.Struct_parts2:
                // <struct_parts> ::= <func_decl> <struct_parts>
                break;

            case Indexes.ProductionIndex.Struct_parts3:
                // <struct_parts> ::= 
                break;
            #endregion

            #region Operators
            case Indexes.ProductionIndex.Operator_Lt:
                // <operator> ::= '<'
                break;

            case Indexes.ProductionIndex.Operator_Gt:
                // <operator> ::= '>'
                break;

            case Indexes.ProductionIndex.Operator_Lteq:
                // <operator> ::= '<='
                break;

            case Indexes.ProductionIndex.Operator_Gteq:
                // <operator> ::= '>='
                break;

            case Indexes.ProductionIndex.Operator_And:
                // <operator> ::= and
                break;

            case Indexes.ProductionIndex.Operator_Or:
                // <operator> ::= or
                break;

            case Indexes.ProductionIndex.Operator_Eqeq:
                // <operator> ::= '=='
                break;

            case Indexes.ProductionIndex.Operator_Exclameq:
                // <operator> ::= '!='
                break;

            case Indexes.ProductionIndex.Operator_Times:
                // <operator> ::= '*'
                break;

            case Indexes.ProductionIndex.Operator_Div:
                // <operator> ::= '/'
                break;

            case Indexes.ProductionIndex.Operator_Mod:
                // <operator> ::= mod
                break;

            case Indexes.ProductionIndex.Operator_Plus:
                // <operator> ::= '+'
                result = new Operator(Indexes.SymbolIndex.Plus);
                break;

            case Indexes.ProductionIndex.Operator_Minus:
                // <operator> ::= '-'
                break;
            #endregion

            #region Types
            case Indexes.ProductionIndex.Type_Void:
                // <type> ::= void
                break;

            case Indexes.ProductionIndex.Type_String:
                // <type> ::= string
                break;

            case Indexes.ProductionIndex.Type_Num:
                // <type> ::= num
                break;

            case Indexes.ProductionIndex.Type_Bool:
                // <type> ::= bool
                break;
            #endregion

            #region Values
            case Indexes.ProductionIndex.Value_Floatliteral:
                // <value> ::= FloatLiteral
                string s = _parser.CurrentToken().Data.ToString();
                result = new NumValue(1.1);
                break;

            case Indexes.ProductionIndex.Value_Stringliteral:
                // <value> ::= StringLiteral
                break;

            case Indexes.ProductionIndex.Value_Booleanliteral:
                // <value> ::= BooleanLiteral
                break;

            case Indexes.ProductionIndex.Value:
                // <value> ::= <func_call>
                result = Stack.Pop() as FuncCall;
                break;

            case Indexes.ProductionIndex.Value_Id:
                // <value> ::= Id
                result = Identifiers.Pop();
                break;
            #endregion

            #region Body&Bodypart
            case Indexes.ProductionIndex.Body:
                // <body> ::= <bodypart> <body>
                
                var b = Stack.Pop() as Body;
                var bp = Stack.Pop() as IBodypart;
                bodyparts.Add(bp);
                bodyparts.AddRange(b.Bodyparts);

                result = new Body(bodyparts);
                break;

            case Indexes.ProductionIndex.Body2:
                // <body> ::= 
                result = new Body();
                break;

            case Indexes.ProductionIndex.Bodypart_Semi:
                // <bodypart> ::= <var_decl> ';'

                result = Stack.Pop() as VarDecleration;
                break;

            case Indexes.ProductionIndex.Bodypart_Semi2:
                // <bodypart> ::= <struct_decl> ';'
                break;

            case Indexes.ProductionIndex.Bodypart_Semi3:
                // <bodypart> ::= <func_call> ';'
                exprs = Stack.Pop() as ExpressionList;
                id = Stack.Pop() as Identifier;
                result = new FuncCall(id, exprs.Expressions);
                break;

            case Indexes.ProductionIndex.Bodypart:
                // <bodypart> ::= <ctrl_stmt>
                break;
            #endregion

            #region Expressions
            case Indexes.ProductionIndex.Expr:
                // <expr> ::= <value> <operator> <expr>
                expr = Stack.Pop() as Expression;
                var opr = Stack.Pop() as Operator;
                result = new ExpressionValOpExpr(Stack.Pop() as IValue, opr, expr);
                break;

            case Indexes.ProductionIndex.Expr2:
                // <expr> ::= <value>
                result = new ExpressionVal(Stack.Pop() as IValue);
                break;

            case Indexes.ProductionIndex.Expr_Lparen_Rparen:
                // <expr> ::= '(' <expr> ')'

                break;

            case Indexes.ProductionIndex.Expr_Minus:
                // <expr> ::= '-' <value>
                break;

            case Indexes.ProductionIndex.Expr_Lparen_Rparen2:
                // <expr> ::= '(' <expr> ')' <operator> <expr>
                break;

            case Indexes.ProductionIndex.Expr_Exclam:
                // <expr> ::= '!' <expr>
                break;

            case Indexes.ProductionIndex.Expr_list:
                // <expr_list> ::= <expr> <opt_exprs>
                exprs = Stack.Pop() as ExpressionList;
                expr = Stack.Pop() as Expression;
                expressionList.Add(expr);
                expressionList.AddRange(exprs.Expressions);
                result = new ExpressionList();
                break;

            case Indexes.ProductionIndex.Expr_list2:
                // <expr_list> ::= 
                result = new ExpressionList();
                break;

            case Indexes.ProductionIndex.Opt_exprs_Comma:
                // <opt_exprs> ::= ',' <expr> <opt_exprs>
                break;

            case Indexes.ProductionIndex.Opt_exprs:
                // <opt_exprs> ::= 
                break;
            #endregion

            #region ControlStatements
            case Indexes.ProductionIndex.Ctrl_stmt_If_Lbrace_Rbrace:
                // <ctrl_stmt> ::= if <expr> '{' <body> '}' <if_exp>
                body = Stack.Pop() as Body; 
                expr = Stack.Pop() as Expression;
                result = new IfStatement(expr, body);
                break;

            case Indexes.ProductionIndex.Ctrl_stmt_Repeat_Lbrace_Rbrace:
                // <ctrl_stmt> ::= repeat <var_decl> <direction> <expr> '{' <body> '}'
                break;

            case Indexes.ProductionIndex.Ctrl_stmt_Repeat_Lparen_Rparen_Lbrace_Rbrace:
                // <ctrl_stmt> ::= repeat '(' <var_decl> <direction> <expr> ')' '{' <body> '}'
                break;

            case Indexes.ProductionIndex.Ctrl_stmt_Repeat:
                // <ctrl_stmt> ::= repeat <expr>
                break;

            case Indexes.ProductionIndex.If_exp_Else_If_Lbrace_Rbrace:
                // <if_exp> ::= else if <expr> '{' <body> '}' <if_exp>
                break;

            case Indexes.ProductionIndex.If_exp_Else_Lbrace_Rbrace:
                // <if_exp> ::= else '{' <body> '}'
                break;

            case Indexes.ProductionIndex.If_exp:
                // <if_exp> ::= 
                break;
            #endregion

            #region Direction
            case Indexes.ProductionIndex.Direction_Downto:
                // <direction> ::= downto
                break;

            case Indexes.ProductionIndex.Direction_To:
                // <direction> ::= to
                break;
            #endregion

            #region FunctionCall
            case Indexes.ProductionIndex.Func_call_Id_Lparen_Rparen:
                // <func_call> ::= Id '(' <expr_list> ')'
                exprs = Stack.Pop() as ExpressionList;
                id = Identifiers.Pop() as Identifier;
                result = new FuncCall(id, exprs.Expressions);
                break; 
            #endregion

        }  //switch

        return result;
    }
}; //MyParser
